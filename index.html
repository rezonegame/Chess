<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ARCADE PRO - ç»ˆææ£‹ç±»å¯¹æˆ˜å¹³å°</title>
    <style>
        /* --- 1. æ ¸å¿ƒè§†è§‰ç³»ç»Ÿ (CSS Variables) --- */
        :root {
            --bg-dark: #0f172a;
            --bg-panel: rgba(30, 41, 59, 0.7);
            --accent-primary: #38bdf8;
            --accent-secondary: #818cf8;
            --text-main: #f1f5f9;
            --text-dim: #94a3b8;
            --border-glass: 1px solid rgba(255, 255, 255, 0.1);
            --shadow-glass: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            
            /* æ£‹ç›˜æè´¨ */
            --board-wood: #e3c188;
            --board-felt: #2e7d32;
            --board-plastic: #2196f3;
        }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background-color: var(--bg-dark);
            /* åŠ¨æ€èƒŒæ™¯ */
            background-image: 
                radial-gradient(at 0% 0%, rgba(56, 189, 248, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 0%, rgba(129, 140, 248, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 100%, rgba(56, 189, 248, 0.15) 0px, transparent 50%);
            background-attachment: fixed;
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* --- 2. å¸ƒå±€ç³»ç»Ÿ --- */
        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* å·¦ä¾§è¾¹æ  (æ¸¸æˆé€‰æ‹©) */
        aside {
            width: 280px;
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            border-right: var(--border-glass);
            display: flex;
            flex-direction: column;
            padding: 20px;
            z-index: 10;
            transition: transform 0.3s;
        }

        .brand {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            letter-spacing: -1px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .game-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .game-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .game-item:hover { background: rgba(255,255,255,0.05); }
        .game-item.active {
            background: rgba(56, 189, 248, 0.15);
            border-color: rgba(56, 189, 248, 0.3);
            color: var(--accent-primary);
        }
        .game-icon { font-size: 1.2rem; margin-right: 12px; width: 30px; text-align: center; }

        /* å³ä¾§ä¸»åŒºåŸŸ */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        header {
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .score-board {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            background: rgba(0,0,0,0.2);
            padding: 8px 20px;
            border-radius: 20px;
        }
        .score-tag span { font-weight: bold; color: var(--accent-primary); }

        /* æ¸¸æˆèˆå° */
        #game-stage {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 20px;
        }

        /* --- 3. æ£‹ç›˜é€šç”¨æ ·å¼ --- */
        .board-wrapper {
            position: relative;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transition: transform 0.3s;
        }

        .board {
            display: grid;
            gap: 1px;
        }

        .cell {
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* æ£‹å­åŠ¨ç”» */
        .piece {
            width: 80%; height: 80%;
            border-radius: 50%;
            transform: scale(0);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            z-index: 2;
        }
        .piece.show { transform: scale(1); }
        .piece.black { background: radial-gradient(circle at 30% 30%, #475569, #0f172a); }
        .piece.white { background: radial-gradient(circle at 30% 30%, #f8fafc, #cbd5e1); }
        
        /* --- 4. ç‰¹å®šæ¸¸æˆçš®è‚¤ --- */
        
        /* äº”å­æ£‹ (æœ¨çº¹) */
        .skin-gomoku {
            background: var(--board-wood);
            border: 8px solid #8d6e63;
        }
        .skin-gomoku .cell {
            width: 36px; height: 36px;
        }
        /* åå­—çº¿ç»˜åˆ¶ */
        .skin-gomoku .cell::before { content:''; position:absolute; top:50%; left:0; width:100%; height:1px; background:#5d4037; }
        .skin-gomoku .cell::after { content:''; position:absolute; left:50%; top:0; height:100%; width:1px; background:#5d4037; }

        /* äº•å­—æ£‹ (éœ“è™¹) */
        .skin-tictactoe {
            background: transparent;
            gap: 10px;
        }
        .skin-tictactoe .cell {
            width: 100px; height: 100px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            font-size: 60px;
            font-weight: 900;
        }
        .skin-tictactoe .piece { box-shadow: none; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: none; }

        /* é»‘ç™½æ£‹ (ç»¿ç»’) */
        .skin-reversi {
            background: var(--board-felt);
            border: 8px solid #1b5e20;
            gap: 2px;
            background-color: #1b5e20; /* çº¿æ¡è‰² */
        }
        .skin-reversi .cell {
            width: 50px; height: 50px;
            background: var(--board-felt);
        }
        /* åˆæ³•è½å­æç¤ºç‚¹ */
        .hint-dot {
            width: 10px; height: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
        }

        /* å››å­æ£‹ (æ‚¬æŒ‚å¼) */
        .skin-connect4 {
            background: var(--board-plastic);
            border: 8px solid #1565c0;
            padding: 10px;
            border-radius: 15px 15px 5px 5px;
            gap: 5px;
        }
        .skin-connect4 .cell {
            width: 60px; height: 60px;
            background: #0d47a1; /* æ·±è“å­”æ´èƒŒæ™¯ */
            border-radius: 50%;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3);
        }
        .skin-connect4 .piece.black { background: #e11d48; } /* çº¢æ–¹ */
        .skin-connect4 .piece.white { background: #fbbf24; } /* é»„æ–¹ */
        .skin-connect4 .piece.show { animation: dropDown 0.5s ease-out forwards; }
        
        @keyframes dropDown {
            from { transform: translateY(-300px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* --- 5. åº•éƒ¨æ§åˆ¶æ  --- */
        .controls {
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            background: rgba(0,0,0,0.2);
        }
        
        button {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn-primary { background: var(--accent-primary); color: #0f172a; }
        .btn-primary:hover { background: #bae6fd; transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }

        /* æ¨¡æ€æ¡† (èƒœè´Ÿæç¤º) */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: #1e293b;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            animation: popIn 0.3s;
        }
        .modal-title { font-size: 2rem; margin-bottom: 10px; }
        
        @keyframes popIn { from{transform:scale(0.8);opacity:0;} to{transform:scale(1);opacity:1;} }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            aside { position: absolute; height: 100%; transform: translateX(-100%); }
            aside.open { transform: translateX(0); }
            header { padding: 15px; }
            #game-stage { align-items: flex-start; overflow-y: auto; }
        }
    </style>
</head>
<body>

<!-- éŸ³æ•ˆåˆæˆæ¨¡å— (éšè—) -->
<div id="audio-context"></div>

<div id="app-container">
    <!-- ä¾§è¾¹æ  -->
    <aside id="sidebar">
        <div class="brand">
            <span>ğŸ²</span> ARCADE PRO
        </div>
        <div class="game-list" id="game-list">
            <!-- JS ç”Ÿæˆåˆ—è¡¨ -->
        </div>
        <div style="font-size: 0.8rem; color: var(--text-dim); text-align: center; margin-top: 20px;">
            å…±æ”¶å½• 30 æ¬¾æ¸¸æˆ<br>4æ¬¾å¢å¼ºç‰ˆå·²å°±ç»ª
        </div>
    </aside>

    <!-- ä¸»ç•Œé¢ -->
    <main>
        <header>
            <div style="display:flex; align-items:center; gap:15px;">
                <button class="btn-secondary" onclick="toggleSidebar()" style="padding:8px;">â˜°</button>
                <h2 id="current-game-name" style="margin:0;">é€‰æ‹©æ¸¸æˆ</h2>
            </div>
            
            <div class="score-board">
                <div class="score-tag">ç©å®¶: <span id="score-player">0</span></div>
                <div class="score-tag">AI: <span id="score-ai">0</span></div>
            </div>
        </header>

        <div id="game-stage">
            <div id="board-container" class="board-wrapper">
                <!-- æ£‹ç›˜å°†æ³¨å…¥åˆ°è¿™é‡Œ -->
                <div style="text-align:center; color: var(--text-dim);">
                    <h3>ğŸ‘ˆ è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€æ¬¾æ¸¸æˆ</h3>
                    <p>æ”¯æŒ æ’¤é”€ã€éŸ³æ•ˆã€AIå¯¹æˆ˜</p>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn-secondary" onclick="GameSystem.undo()">â†©ï¸ æ‚”æ£‹</button>
            <button class="btn-primary" onclick="GameSystem.restart()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            <button class="btn-secondary" id="diff-btn" onclick="GameSystem.toggleDifficulty()">ğŸ¤– éš¾åº¦: ç®€å•</button>
        </div>
    </main>
</div>

<!-- æ¸¸æˆç»“æŸå¼¹çª— -->
<div id="modal-overlay">
    <div class="modal-content">
        <div class="modal-title" id="modal-title">ğŸ† èƒœåˆ©</div>
        <p id="modal-msg">ä½ å‡»è´¥äº† AIï¼</p>
        <br>
        <button class="btn-primary" onclick="closeModal()">å†æ¥ä¸€å±€</button>
    </div>
</div>

<script>
    // --- 1. éŸ³æ•ˆç³»ç»Ÿ (Web Audio API - æ— éœ€å¤–éƒ¨æ–‡ä»¶) ---
    const AudioSys = {
        ctx: new (window.AudioContext || window.webkitAudioContext)(),
        
        playTone(freq, type, duration) {
            if (this.ctx.state === 'suspended') this.ctx.resume();
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },

        move() { this.playTone(300, 'sine', 0.1); }, // è½å­å£°
        win() { 
            // èƒœåˆ©å’Œå¼¦
            setTimeout(()=>this.playTone(400, 'triangle', 0.3), 0);
            setTimeout(()=>this.playTone(500, 'triangle', 0.3), 200);
            setTimeout(()=>this.playTone(800, 'triangle', 0.6), 400);
        },
        lose() { this.playTone(150, 'sawtooth', 0.5); }, // å¤±è´¥å£°
        error() { this.playTone(100, 'square', 0.2); } // é”™è¯¯å£°
    };

    // --- 2. æ¸¸æˆé…ç½®åˆ—è¡¨ ---
    const GAMES = [
        { id: 'gomoku', name: 'äº”å­æ£‹', icon: 'âš«', type: 'playable' },
        { id: 'reversi', name: 'é»‘ç™½æ£‹ (å¥¥èµ›ç½—)', icon: 'âšª', type: 'playable' },
        { id: 'connect4', name: 'å››å­æ£‹', icon: 'ğŸ”´', type: 'playable' },
        { id: 'tictactoe', name: 'äº•å­—æ£‹', icon: 'âŒ', type: 'playable' },
        { id: 'chess', name: 'å›½é™…è±¡æ£‹', icon: 'â™Ÿï¸', type: 'dev' },
        { id: 'xiangqi', name: 'ä¸­å›½è±¡æ£‹', icon: 'ğŸ', type: 'dev' },
        { id: 'go', name: 'å›´æ£‹', icon: 'ğŸ”²', type: 'dev' },
        { id: 'checkers', name: 'è·³æ£‹', icon: 'ğŸ’', type: 'dev' },
        { id: 'ludo', name: 'é£è¡Œæ£‹', icon: 'âœˆï¸', type: 'dev' },
        { id: 'shogi', name: 'å°†æ£‹', icon: 'ğŸ¯', type: 'dev' }
        // ... (æ­¤å¤„çœç•¥å…¶ä»–åç§°ä»¥èŠ‚çœç©ºé—´ï¼Œé€»è¾‘é€šç”¨)
    ];
    // è¡¥è¶³åˆ°30ä¸ªå±•ç¤ºç”¨
    const Extras = ["æ–—å…½æ£‹","å†›æ£‹","ä¹å­æ£‹","å…­å­æ£‹","è¥¿æ´‹è·³æ£‹","åŒé™†æ£‹","å­”æ˜æ£‹","äºšé©¬é€Šæ£‹","è‹æ‹‰å¡å°”å¡”","æ’­æ£‹","æµ·æˆ˜æ£‹","ç‚¹æ ¼æ£‹","ç”±å–æ£‹","è€é¼ ä¸è±¡","å±é£é©¬","å¦‚æœæ£‹","åŸå­æ£‹","è´¯é€šæ£‹","å¤šç±³è¯º","ç‹¼äººæ£‹"];
    Extras.forEach((n,i) => GAMES.push({ id: `ex${i}`, name: n, icon: 'ğŸ²', type: 'dev' }));


    // --- 3. æ¸¸æˆç³»ç»Ÿæ ¸å¿ƒ (GameSystem) ---
    const GameSystem = {
        activeGame: null,
        scores: { player: 0, ai: 0 },
        difficulty: 'easy', // 'easy' or 'hard'

        init() {
            this.renderSidebar();
            // é»˜è®¤åŠ è½½äº”å­æ£‹
            this.loadGame('gomoku');
        },

        renderSidebar() {
            const list = document.getElementById('game-list');
            GAMES.forEach(g => {
                const el = document.createElement('div');
                el.className = 'game-item';
                el.innerHTML = `<span class="game-icon">${g.icon}</span> ${g.name}`;
                if(g.type==='dev') el.style.opacity = '0.6';
                el.onclick = () => this.loadGame(g.id);
                list.appendChild(el);
            });
        },

        loadGame(id) {
            const gameConfig = GAMES.find(g => g.id === id);
            if (gameConfig.type === 'dev') {
                AudioSys.error();
                alert(`ğŸš§ [${gameConfig.name}] æ­£åœ¨é‡åˆ¶é«˜æ¸…æè´¨å’ŒAIï¼Œè¯·å…ˆè¯•ç©å‰4æ¬¾å¢å¼ºç‰ˆæ¸¸æˆï¼`);
                return;
            }

            // æ›´æ–° UI
            document.querySelectorAll('.game-item').forEach(el => el.classList.remove('active'));
            // ç®€å•æŸ¥æ‰¾é«˜äº® (å®é™…åº”ç”¨å¯ç”¨IDåŒ¹é…)
            Array.from(document.querySelectorAll('.game-item')).find(el => el.textContent.includes(gameConfig.name)).classList.add('active');
            document.getElementById('current-game-name').innerText = gameConfig.name;

            // å®ä¾‹åŒ–æ¸¸æˆå¼•æ“
            if (this.activeGame) this.activeGame = null;
            
            const container = document.getElementById('board-container');
            container.className = 'board-wrapper'; // é‡ç½®ç±»
            
            switch(id) {
                case 'gomoku': this.activeGame = new GomokuEngine(); break;
                case 'reversi': this.activeGame = new ReversiEngine(); break;
                case 'connect4': this.activeGame = new Connect4Engine(); break;
                case 'tictactoe': this.activeGame = new TicTacToeEngine(); break;
            }

            container.classList.add(this.activeGame.skinClass);
            this.activeGame.init();
        },

        undo() { if(this.activeGame) this.activeGame.undo(); },
        restart() { if(this.activeGame) this.activeGame.init(); },
        
        toggleDifficulty() {
            this.difficulty = this.difficulty === 'easy' ? 'hard' : 'easy';
            document.getElementById('diff-btn').innerText = `ğŸ¤– éš¾åº¦: ${this.difficulty === 'easy' ? 'ç®€å•' : 'å›°éš¾'}`;
            this.restart();
        },

        endGame(winner) { // 1: Player, 2: AI, 0: Draw
            if (winner === 1) {
                this.scores.player++;
                AudioSys.win();
                showModal('ğŸ‰ èƒœåˆ©ï¼', 'ä½ çš„æ£‹è‰ºä»¤äººæƒŠå¹ï¼');
            } else if (winner === 2) {
                this.scores.ai++;
                AudioSys.lose();
                showModal('ğŸ’” æƒœè´¥', 'AI è¿™æ¬¡ç•¥èƒœä¸€ç­¹ã€‚');
            } else {
                AudioSys.lose();
                showModal('ğŸ¤ å¹³å±€', 'æ£‹é€¢å¯¹æ‰‹ã€‚');
            }
            this.updateScoreUI();
        },

        updateScoreUI() {
            document.getElementById('score-player').innerText = this.scores.player;
            document.getElementById('score-ai').innerText = this.scores.ai;
        }
    };

    // --- 4. æ¸¸æˆå¼•æ“ç±» (OOP) ---
    
    // åŸºç±»
    class BaseGame {
        constructor() {
            this.board = [];
            this.history = []; // æ‚”æ£‹æ ˆ
            this.currentPlayer = 1; // 1: Player, 2: AI
            this.isOver = false;
            this.container = document.getElementById('board-container');
        }

        render() { /* å­ç±»å®ç° */ }
        
        makeMove(x, y, player) {
            this.history.push(JSON.parse(JSON.stringify(this.board))); // ä¿å­˜å¿«ç…§
            this.board[y][x] = player;
            this.renderPiece(x, y, player);
            AudioSys.move();
        }

        undo() {
            if (this.isOver || this.history.length === 0 || this.currentPlayer !== 1) return;
            // å›é€€ä¸¤æ­¥ (å› ä¸ºAIä¸‹äº†ä¸€æ­¥)
            if (this.history.length >= 2) {
                this.history.pop(); // pop AI move
                this.board = this.history.pop(); // pop & restore player move
                this.render(); // é‡ç»˜
            }
        }

        switchTurn() {
            if (this.isOver) return;
            this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
            if (this.currentPlayer === 2) {
                setTimeout(() => this.aiMove(), 600);
            }
        }

        // ç®€å•çš„éšæœº+æƒé‡ AI æ¡†æ¶ (å­ç±»é‡å†™ getBestMove)
        aiMove() {
            const move = this.getBestMove();
            if (move) {
                this.makeMove(move.x, move.y, 2);
                const win = this.checkWin(move.x, move.y, 2);
                if (win) { this.isOver = true; GameSystem.endGame(2); }
                else if (this.checkDraw()) { this.isOver = true; GameSystem.endGame(0); }
                else this.switchTurn();
            }
        }

        checkDraw() {
            return this.board.every(row => row.every(cell => cell !== 0));
        }
    }

    // --- äº”å­æ£‹å¼•æ“ ---
    class GomokuEngine extends BaseGame {
        constructor() { super(); this.size = 15; this.skinClass = 'skin-gomoku'; }

        init() {
            this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.history = []; this.currentPlayer = 1; this.isOver = false;
            this.render();
        }

        render() {
            this.container.innerHTML = '';
            const el = document.createElement('div');
            el.className = 'board';
            el.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
            
            for(let y=0; y<this.size; y++) {
                for(let x=0; x<this.size; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => this.handleInput(x, y);
                    if (this.board[y][x] !== 0) {
                        const p = document.createElement('div');
                        p.className = `piece ${this.board[y][x]===1?'black':'white'} show`;
                        cell.appendChild(p);
                    }
                    el.appendChild(cell);
                }
            }
            this.container.appendChild(el);
        }

        renderPiece(x, y, p) {
            const index = y * this.size + x;
            const cell = this.container.querySelector('.board').children[index];
            const piece = document.createElement('div');
            piece.className = `piece ${p===1?'black':'white'}`;
            cell.appendChild(piece);
            setTimeout(()=>piece.classList.add('show'), 10);
        }

        handleInput(x, y) {
            if (this.isOver || this.currentPlayer !== 1 || this.board[y][x] !== 0) return;
            this.makeMove(x, y, 1);
            if (this.checkWin(x, y, 1)) { this.isOver=true; GameSystem.endGame(1); }
            else this.switchTurn();
        }

        checkWin(x, y, p) {
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            for(let [dx, dy] of dirs) {
                let c = 1;
                for(let k of [1,-1]) {
                    let i=1;
                    while(true) {
                        let nx=x+dx*i*k, ny=y+dy*i*k;
                        if(nx<0||ny<0||nx>=this.size||ny>=this.size||this.board[ny][nx]!==p) break;
                        c++; i++;
                    }
                }
                if(c>=5) return true;
            }
            return false;
        }

        getBestMove() {
            // ç®€å•çš„è¯„åˆ†é€»è¾‘
            let bestScore = -Infinity;
            let bestMoves = [];
            for(let y=0; y<this.size; y++){
                for(let x=0; x<this.size; x++){
                    if(this.board[y][x]===0){
                        // ç®€å•éš¾åº¦ï¼šåªçœ‹å‘¨å›´ï¼›å›°éš¾éš¾åº¦ï¼šçœ‹è¿çº¿
                        let score = GameSystem.difficulty === 'easy' ? Math.random() : 0;
                        if(GameSystem.difficulty === 'hard') {
                            // æç®€ç‰ˆå¯å‘å¼è¯„åˆ†
                            score += this.evalLine(x,y,2) * 1.2; // è¿›æ”»
                            score += this.evalLine(x,y,1) * 1.0; // é˜²å®ˆ
                        }
                        if(score > bestScore) { bestScore=score; bestMoves=[{x,y}]; }
                        else if(score === bestScore) bestMoves.push({x,y});
                    }
                }
            }
            return bestMoves.length ? bestMoves[Math.floor(Math.random()*bestMoves.length)] : {x:7,y:7};
        }

        evalLine(x, y, p) {
            // æ£€æŸ¥å¦‚æœä¸å µ/ä¸ä¸‹è¿™é‡Œï¼Œä¼šå½¢æˆå‡ ä¸ªè¿å­
            let maxLink = 0;
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            for(let [dx, dy] of dirs) {
                let c = 0;
                for(let k of [1,-1]) {
                    let i=1; 
                    while(i<5) {
                        let nx=x+dx*i*k, ny=y+dy*i*k;
                        if(nx>=0&&ny>=0&&nx<this.size&&ny<this.size&&this.board[ny][nx]===p) c++;
                        else break;
                        i++;
                    }
                }
                if(c>maxLink) maxLink = c;
            }
            // æƒé‡ï¼š4è¿æé«˜ï¼Œ3è¿ä¸­ç­‰
            if(maxLink>=4) return 10000;
            if(maxLink===3) return 1000;
            if(maxLink===2) return 100;
            return maxLink;
        }
    }

    // --- é»‘ç™½æ£‹å¼•æ“ ---
    class ReversiEngine extends BaseGame {
        constructor() { super(); this.size = 8; this.skinClass = 'skin-reversi'; }

        init() {
            this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
            // åˆå§‹å¸ƒå±€
            this.board[3][3]=2; this.board[3][4]=1; this.board[4][3]=1; this.board[4][4]=2;
            this.history = []; this.currentPlayer = 1; this.isOver = false;
            this.render();
        }

        render() {
            this.container.innerHTML = '';
            const el = document.createElement('div');
            el.className = 'board';
            el.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
            
            // è®¡ç®—åˆæ³•è½å­ç‚¹
            const validMoves = this.getValidMoves(this.currentPlayer);

            for(let y=0; y<this.size; y++) {
                for(let x=0; x<this.size; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (this.board[y][x] !== 0) {
                        const p = document.createElement('div');
                        p.className = `piece ${this.board[y][x]===1?'black':'white'} show`;
                        cell.appendChild(p);
                    } else if (this.currentPlayer === 1 && validMoves.some(m => m.x===x && m.y===y)) {
                        // æ˜¾ç¤ºæç¤ºç‚¹
                        const dot = document.createElement('div');
                        dot.className = 'hint-dot';
                        cell.appendChild(dot);
                        cell.onclick = () => this.handleInput(x, y);
                    }
                    el.appendChild(cell);
                }
            }
            this.container.appendChild(el);
        }

        handleInput(x, y) {
            if (this.isOver) return;
            const flipped = this.getFlips(x, y, 1);
            if (flipped.length > 0) {
                this.makeMove(x, y, 1, flipped);
                this.switchTurn();
            }
        }

        makeMove(x, y, p, flips) {
             this.history.push(JSON.parse(JSON.stringify(this.board)));
             this.board[y][x] = p;
             flips.forEach(pt => this.board[pt.y][pt.x] = p);
             this.render(); // é»‘ç™½æ£‹éœ€è¦é‡ç»˜ç¿»è½¬æ•ˆæœ
             AudioSys.move();
        }

        switchTurn() {
            this.currentPlayer = 3 - this.currentPlayer;
            const moves = this.getValidMoves(this.currentPlayer);
            if (moves.length === 0) {
                // æ— æ£‹å¯èµ°ï¼Œè·³è¿‡
                this.currentPlayer = 3 - this.currentPlayer;
                const oppMoves = this.getValidMoves(this.currentPlayer);
                if (oppMoves.length === 0) {
                    // åŒæ–¹éƒ½æ— æ£‹å¯èµ°ï¼Œç»“æŸ
                    this.countScore();
                    return;
                }
                if (this.currentPlayer === 2) setTimeout(() => this.aiMove(), 600);
                else this.render();
            } else {
                if (this.currentPlayer === 2) setTimeout(() => this.aiMove(), 600);
                else this.render();
            }
        }

        countScore() {
            let black = 0, white = 0;
            this.board.forEach(r => r.forEach(c => { if(c===1) black++; if(c===2) white++; }));
            this.isOver = true;
            if (black > white) GameSystem.endGame(1);
            else if (white > black) GameSystem.endGame(2);
            else GameSystem.endGame(0);
        }

        getValidMoves(p) {
            let moves = [];
            for(let y=0; y<this.size; y++)
                for(let x=0; x<this.size; x++)
                    if(this.board[y][x]===0 && this.getFlips(x,y,p).length>0) moves.push({x,y});
            return moves;
        }

        getFlips(x, y, p) {
            let flips = [];
            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            const opp = 3 - p;
            for (let [dx, dy] of dirs) {
                let temp = [], i=1;
                while(true) {
                    let nx=x+dx*i, ny=y+dy*i;
                    if(nx<0||ny<0||nx>=8||ny>=8) break;
                    if(this.board[ny][nx]===opp) temp.push({x:nx, y:ny});
                    else if(this.board[ny][nx]===p) { flips.push(...temp); break; }
                    else break;
                    i++;
                }
            }
            return flips;
        }

        getBestMove() {
            const moves = this.getValidMoves(2);
            if (!moves.length) return null;
            // ç®€å•çš„ä½ç½®æƒé‡ (è§’è½æœ€é‡è¦)
            const weights = [
                [100,-10,10,5,5,10,-10,100],
                [-10,-20,1,1,1,1,-20,-10],
                [10,1,5,2,2,5,1,10],
                [5,1,2,1,1,2,1,5],
                [5,1,2,1,1,2,1,5],
                [10,1,5,2,2,5,1,10],
                [-10,-20,1,1,1,1,-20,-10],
                [100,-10,10,5,5,10,-10,100]
            ];
            
            // å›°éš¾æ¨¡å¼é€‰æƒé‡æœ€é«˜çš„ï¼Œç®€å•æ¨¡å¼éšæœº
            if (GameSystem.difficulty === 'easy') return moves[Math.floor(Math.random()*moves.length)];
            
            let best = moves[0], maxW = -9999;
            moves.forEach(m => {
                let w = weights[m.y][m.x];
                if (w > maxW) { maxW = w; best = m; }
            });
            return best;
        }
        
        aiMove() {
             const move = this.getBestMove();
             if(move) {
                 const flips = this.getFlips(move.x, move.y, 2);
                 this.makeMove(move.x, move.y, 2, flips);
                 this.switchTurn();
             }
        }
    }

    // --- å››å­æ£‹å¼•æ“ ---
    class Connect4Engine extends BaseGame {
        constructor() { super(); this.cols=7; this.rows=6; this.skinClass='skin-connect4'; }
        
        init() {
            this.board = Array(this.rows).fill().map(()=>Array(this.cols).fill(0));
            this.history=[]; this.currentPlayer=1; this.isOver=false;
            this.render();
        }

        render() {
            this.container.innerHTML='';
            const el = document.createElement('div');
            el.className='board';
            el.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
            
            // å››å­æ£‹æŒ‰åˆ—ç‚¹å‡»ï¼Œä½†è§†è§‰ä¸Šæ˜¯ç½‘æ ¼
            for(let y=0; y<this.rows; y++) {
                for(let x=0; x<this.cols; x++) {
                    const cell = document.createElement('div');
                    cell.className='cell';
                    // ç‚¹å‡»ä»»æ„æ ¼éƒ½ç®—ç‚¹å‡»è¯¥åˆ—
                    cell.onclick = () => this.handleInput(x); 
                    if(this.board[y][x]!==0) {
                        const p=document.createElement('div');
                        p.className=`piece ${this.board[y][x]===1?'black':'white'} show`; // black=red, white=yellow in css
                        cell.appendChild(p);
                    }
                    el.appendChild(cell);
                }
            }
            this.container.appendChild(el);
        }

        handleInput(x) {
            if(this.isOver || this.currentPlayer!==1) return;
            // å¯»æ‰¾è¯¥åˆ—æœ€åº•éƒ¨çš„ç©ºä½
            const y = this.getDropRow(x);
            if(y === -1) return; // åˆ—æ»¡äº†

            this.makeMove(x, y, 1);
            if(this.checkWin(x,y,1)) { this.isOver=true; GameSystem.endGame(1); }
            else this.switchTurn();
        }

        getDropRow(x) {
            for(let y=this.rows-1; y>=0; y--) {
                if(this.board[y][x]===0) return y;
            }
            return -1;
        }

        getBestMove() {
            // AI
            let validCols = [];
            for(let x=0; x<this.cols; x++) if(this.getDropRow(x)!==-1) validCols.push(x);
            
            if(GameSystem.difficulty==='easy') return {x: validCols[Math.floor(Math.random()*validCols.length)]};

            // Hard: ç®€å•çš„å µè·¯é€»è¾‘
            // 1. èµ¢æ£‹
            for(let x of validCols) {
                let y = this.getDropRow(x);
                this.board[y][x]=2; 
                if(this.checkWin(x,y,2)) { this.board[y][x]=0; return {x, y}; }
                this.board[y][x]=0;
            }
            // 2. å µäºº
            for(let x of validCols) {
                let y = this.getDropRow(x);
                this.board[y][x]=1; 
                if(this.checkWin(x,y,1)) { this.board[y][x]=0; return {x, y}; }
                this.board[y][x]=0;
            }
            
            return {x: validCols[Math.floor(Math.random()*validCols.length)]};
        }

        aiMove() {
            const move = this.getBestMove();
            const y = this.getDropRow(move.x);
            this.makeMove(move.x, y, 2);
             if(this.checkWin(move.x,y,2)) { this.isOver=true; GameSystem.endGame(2); }
             else if(this.board.every(r=>r.every(c=>c!==0))) {this.isOver=true;GameSystem.endGame(0);}
             else this.switchTurn();
        }

        checkWin(x,y,p) {
            // ç®€åŒ–çš„æ–¹å‘æ£€æŸ¥
             const dirs = [[1,0], [0,1], [1,1], [1,-1]];
             for(let [dx, dy] of dirs) {
                let count = 0;
                // å…¨ç›˜æ‰«æè¿çº¿ï¼ˆæ•ˆç‡è¾ƒä½ä½†ä»£ç å°‘ï¼‰
                // å®é™…ä¸Šåº”è¯¥ä» x,y æ‰©æ•£ï¼Œä½†è¿™é‡Œä¸ºäº†é€»è¾‘å¤ç”¨ Gomoku ä¹Ÿå¯ä»¥
                // å››å­æ£‹ç‰¹æ®Šçš„ï¼šåªéœ€è¦æŸ¥ç»è¿‡ x,y çš„çº¿
                let c = 1;
                for(let k of [1,-1]) {
                    let i=1;
                    while(true) {
                        let nx=x+dx*i*k, ny=y+dy*i*k;
                        if(nx<0||nx>=this.cols||ny<0||ny>=this.rows||this.board[ny][nx]!==p) break;
                        c++; i++;
                    }
                }
                if(c>=4) return true;
             }
             return false;
        }
    }

    // --- äº•å­—æ£‹å¼•æ“ (å¤ç”¨é€»è¾‘) ---
    class TicTacToeEngine extends GomokuEngine {
        constructor() { super(); this.size=3; this.skinClass='skin-tictactoe'; }
        
        renderPiece(x,y,p) {
            const index = y * this.size + x;
            const cell = this.container.querySelector('.board').children[index];
            cell.innerText = p===1 ? 'âŒ' : 'â­•';
            cell.style.color = p===1 ? '#38bdf8' : '#f472b6';
            cell.classList.add('popIn');
        }

        render() {
            this.container.innerHTML = '';
            const el = document.createElement('div');
            el.className = 'board';
            el.style.gridTemplateColumns = `repeat(3, 1fr)`;
            el.style.width = '320px'; // é™åˆ¶å¤§å°
            
            for(let y=0; y<3; y++) {
      
